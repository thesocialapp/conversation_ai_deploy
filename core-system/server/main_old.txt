package main

import (
	"strconv"
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
	"github.com/my/project/communication"
	"github.com/my/project/config"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/my/project/socket" 
)

// Constants for Socket.IO event names
const TextProcessed = "text_processed"

var logger, _ = zap.NewProduction()

func main() {
	// Start the Socket.IO server concurrently.
	err := socket.CreateServer() // This function should block and handle Socket.IO connections.
	if err != nil {
		logger.Errorw("Failed to start Socket.IO server", "error", err)
		return
	}

	router := gin.Default()

	// Health check endpoint
	router.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"status": "ok",
		})
	})

	// Metrics endpoint
	router.GET("/metrics", gin.WrapH(promhttp.Handler()))

	port := config.Config.Port
	router.Run(":" + strconv.Itoa(port)) 
}

func handleText(c *gin.Context) {
	var input struct {
		Text string `json:"text"`
	}

	if err := c.BindJSON(&input); err != nil {
		logger.Errorw("Invalid input",
			"error", err)
		c.AbortWithStatus(400)
		return
	}

	// Pass the trace ID to ProcessText.
	traceID := c.GetHeader("X-Trace-ID")

	resp, err := communication.ProcessText(traceID, input.Text)
	if err != nil {
		logger.Errorw("Failed to call Python service",
			"error", err)
		c.AbortWithStatus(500)
		return
	}

	// Wait for socket connection before emitting events.
	socket.OnConnect(func() {
		socket.Emit(TextProcessed, gin.H{
			"response": resp,
		})
	})
}
